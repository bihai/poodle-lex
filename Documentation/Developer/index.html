<html>
    <head>
        <title>Poodle-Lex Developer Documentation</title>
        <link rel="stylesheet" href="style.css" />
    </head>
    <body>
        <h1>Poodle-Lex Developer Documentation</h1>
        <p>This documentation is meant to provide an introduction into 
        understanding the Poodle-Lex source code for anyone who wishes to
        develop for, borrow from, or simply learn about the application.</p>
        
        <h2>Getting Started</h2>
        <p>Poodle-Lex is written in Python. To run Poodle-Lex from source, 
        install the following dependencies</p>
        <ul>
            <li><a href="https://www.python.org/">Python 2</a>, version 2.7 or higher</a></li>
            <li><a href="https://pypi.python.org/pypi/blist/">blist</a></li>
            <li><a href="http://git-scm.com/downloads">Git</a></li>
        </ul>
        
        <p>Once all dependencies have been acquired, clone the Poodle-Lex
        repository using git:</p>
        <code>git clone https://github.com/parkertomatoes/poodle-lex.git</code>
        <p>Create a folder to hold the source and navigate to it in a command 
        prompt or terminal. Then run __main__.py using Python:</p>
        <code>mkdir Output
python __main__.py Example/SimpleLexer/SimpleLexer.rules Output</code>
        
        <h2>Overview</h2>
        <p>Poodle-Lex consumes a rules file containing regular expressions and
        produces source code which can accept strings and match them to 
        rules. It does this though a series of steps which are a well 
        known part of compter science.<p>
        <ol>
            <li>Parse a rules file into a list of name and regular expression strings</li>
            <li>Parse each regular expression into a structure</li>
            <li>Convert each regular expression into an NFA using 
            <a href="http://en.wikipedia.org/wiki/Thompson's_construction_algorithm">Thompson Construction</a></li>
            <li>Convert each NFA into a DFA using 
            <a href="http://en.wikipedia.org/wiki/Powerset_construction">powerset construction</a></li>
            <li>Minimize the DFA</li>
            <li>Emit the DFA as source code</li>
        </ol>
        
        <h2>Parsing the rules file</h2>
        <p><em>Source file: <a href="">Generator/LexicalAnalyzerParser.py</a></em></p>
        <p>Before creating a lexical analyzer, Poodle-Lex parses a rules file 
        to obtain a list of rules and variables.</p>
        <p>The parser is a hand-made recursive descent parser which uses 
        the output of
        <a href"http://docs.python.org/library/re.html">re.finditer</a>
        as a lexical analyzer</a>. The parser is an iterator generator
        which yields both rules and variable definitions.</p>
        
        <p>The parser is only accessed through the static method
        <a href="">LexicalAnalyzer.parse()</a>,
        which takes in a filename and outputs a
        <a href="">LexicalAnalyzer()</a> structure.</a>        
        
        <h3>Rules File Grammar</h3>
        <ul>
            <li><strong>body:</strong> line+;</li>
            <li><strong>line:</strong> ws (comment | variable_definition | rule_definition)? ws "\r"? "\n";</li>
            <li><strong>comment:</strong> "#" [^\n]+;</li>
            <li><strong>variable_definition:</strong> "let" ws identifier ws "=" ws rule_expression;</li>
            <li><strong>rule_definition:</strong> (identifier ws)? identifier ws ":" ws rule_expression;</li>
            <li><strong>rule_expression:</strong> "i"? string (ws "+" wsnl string)*;</li>
            <li><strong>string:</strong> double_quote_string | single_quote_string;
            <li><strong>double_quoted_string:</strong> '"' ([^'"'] | '""')* '"';</li>
            <li><strong>single_quoted_string:</strong> "'" ([^"'"] | "''")* "'";</li>
            <li><strong>ws:</strong> [ \t]*;</li>
            <li><strong>wsnl:</strong> [ \t\r\n]*;</li>
        </ul>

        <h2>Parsing the regular expressions</h2>
        <p><em>Source files:</em></p>
        <ul>
            <li><em>Parser: <a href="">Generator/RegexParser.py</a></em></li>
            <li><em>Structure: <a href="">Generator/Regex.py</a></em></li>
        </ul>
        <p>Once the rules file is parsed into a list of rules and variable 
        definitions, each regular expression is represented with a string.
        To be usable, the string is parsed into an 
        <a href="http://en.wikipedia.org/wiki/Visitor_pattern">visitable</a> 
        abstract tree representing the reglar expression. Each object in 
        the tree is either a set of characters or a relationship between
        other tree elements:</p>
        <ul>
            <li><a href="">Literal:</a> the primitive tree element, matches a single character (a, [ab])</li>
            <li><a href="">Alternation:</a> matches one of several tree elements (a|b)</li>
            <li><a href="">Concatenation:</a> matches a sequence of tree elements (ab)</li>
            <li><a href="">Repetition:</a> matches a single tree element repeated a number of times (a*, a+, a?, a{1, 2})</li>
            <li><a href="">Variable instance:</a> Placeholder to be substituted with another tree element ({a})</li>
        </ul>
       
        <p>For example, "cat+|dog" is parsed into the following structure:</p>
        <div class="indent">Alternation(
            <div class="indent">Repetition(
                <div class="indent">Concatenation(
                    <div class="indent">Literal("c"),</div>
                    <div class="indent">Literal("a"),</div>
                    <div class="indent">Literal("t")</div>
                ),</div>
            1, inf),</div>
            <div class="indent">Concatenation(
                <div class="indent">Literal("d"),</div>
                <div class="indent">Literal("o"),</div>
                <div class="indent">Literal("g")</div>
            )</div>
        )</div>
        
        <p>Like the rules file parser, the regular expression parser is 
        a hand-made recursive descent parser. It takes in individual 
        characters as its terminals. Because of this, a dedicated lexical is 
        not necessary.</p>
        
        <h3> Regular Expression Grammar</h3>
        <ul>
            <li><strong>pattern:</strong> concatenation ( "|" concatenation )+</li>
            <li><strong>concatenation:</strong> repetition+;</li>
            <li><strong>repetition:</strong> character ("+" | "*" | "?" | "{" integer "," integer "}")?;</li>
            <li><strong>character:</strong> literal | "(" pattern ")" | variable | character_class;</li>
            <li><strong>literal:</strong> escape_sequence | [^"\\"];</li>
            <li><strong>escape_sequence:</strong> "\\" ([^Uux] | hex_ascii | hex_ucs2 | hex_unicode);</li>
            <li><strong>hex_ascii:</strong> "x" [0-9a-fA-F]{2,2};</li>
            <li><strong>hex_ucs2:</strong> "u" [0-9a-fA-F]{4,4};</li>
            <li><strong>hex_unicode:</strong> "U" [0-9a-fA-F][6,6];</li>
            <li><strong>variable:</strong> "{" identifier "}";</li>
            <li><strong>identifier:</strong> [a-zA-Z][a-zA-Z0-9_]*</li>
            <li><strong>character_class:</strong> "[" character_class_item+ "]";</li>
            <li><strong>character_class_item:</strong> named_character_class | literal ("-" literal)?;</li>
            <li><strong>named_character_class:</strong> "[:" [a-z]{5,5} ":]";</li>
        </ul>
        
        <h2>Converting the regular expressions to an NFA</h2>
        <p><em>Source files:</em></p>
        <ul>
            <li><em>NFA Structure: <a href="">Generator/_NonDeterministicFiniteAutomata.py</em></a></li>
            <li><em>Conversion: <a href="">Generator/NonDeterministicFiniteAutomataBuilder.py</em></a></li>
        </ul>
        <p>Before the regular expression is converted to code, it must be 
        converted into a non-deterministic finite automaton (NFA). An NFA is a 
        state machine which has one start state and one end state, and an be 
        in more than one state at a time. NFA's are difficult to simulate on a 
        CPU, but easy to generate from a regular expression.</p>
        <p>Poodle-lex converts regular expressions to NFAs using the Thompson 
        Construction algorithm, sometimes called subset construction. General 
        information about NFAs and Thompson construction are beyond the scope 
        of this document, but there is abundent information about these 
        topics. See the resources below for more information:
        <ul>
            <li><a href="">Wikipedia</a></li>
            <li>MIT OpenCourseware: Aaronson, Scott. 6.045J 
            Automata, Computability, and Complexity, Spring 2011. (MIT 
            OpenCourseWare: Massachusetts Institute of Technology), 
            <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-045j-automata-computability-and-complexity-spring-2011 (Accessed 29 Mar, 2014). License: Creative Commons BY-NC-SA">http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-045j-automata-computability-and-complexity-spring-2011</a>. 
            License: Creative Commons BY-NC-SA</a></li>
            <li><a href="https://www.google.com/search?q=nondeterministic+finite+automata">Google search</a> which brings up tons of university slides.</li>
        </ul>
        
        <h3>The NFA data structure</h3>
        <p>NFAs are stored in Poodle-Lex using the 
        NonDeterministicFiniteAutomata 
        class. This class does little except to point to
        the start and end states of the class. The states, each represented 
        by a 
        NonDeterministicState 
        object, define most of the structure of the NFA.</p>
        
        <p>Each state contains four main components:</p>
        <ul>
            <li><strong>epsilon_edges</strong>: A set of 
                NonDeterministicState 
                objects connected by epsilon edges.</li>
            <li><strong>edges</strong>: Represents transitions to other 
                states. edges is a dict, with the keys being a 
                NonDeterministicState object representing the destination of 
                the edges, and the values being a range of values which cause
                a transition to that other state. The range of values is
                represented by a 
                ConverageSet
                object.</li>
            <li><strong>ids</strong>: Contains a set of possible
                rules which can be eventually matched if in this
                state.</li>
            <li><strong>final_ids</strong>: If this state is a
                final state, contains a set of names of rules which are 
                current matched in this state.</li>
        </ul>
        
        <p>For example, consider the following NFA, which matches 'a' or 'aaa':</p>
        <img src="simple-nfa.png" alt="A simple NFA matching 'a' or 'aaa'" />
        <p>This state machine can be created with the following Python code:</p>
        <code># Value of an edge 'a'
a = CoverageSet([(ord('a'), ord('a'))])
        
# State machine and states
state_machine = Automata.NonDeterministicFiniteAutomata()
s1 = Automata.NonDeterministicState()
s2 = Automata.NonDeterministicState()

# Edges
state_machine.start_state.edges[s1] = a
s1.edges[s2] = a
s1.epsilon_edges.add(state_machine.end_state)
s2.edges[state_machine.end_state] = a
        </code>
        
        <h3>Building the NFA from a regular expression structure</h3>
        <p>Thompson Construction is relatively simple. Once a regular 
        expression is broken down into parts (Alternation, Concatenation, 
        etc), each part can be substituted for an equivalent NFA 
        representation. Different representations are chained together
        with epsilon edges.</p>
        <p>To recursively iterate though the regular expression tree
        structure, Poodle-Lex makes use of a
        <a href="">visitor</a> 
        class to act differently on different types of tree elements, the 
        <a href="">NonDeterministicFiniteAutomata</a>
        class. This class visits the root of the tree, and first
        visits the children of each node, pushing their equivelent NFA onto 
        a stack. Then the children are popped off the stack and merged
        using static helper methods such as 
        <a href ="">Alternate</a>
        and 
        <a href ="">Concatenate</a>. Because visiting each child means the
        entire tree is visited, visiting the root of the tree results in an
        NFA equivalent to the entire regular expression.</p>
        
        <h3>Combining several individual rules into one NFA</h3>
        <p>Multiple regular expression "rules" can be merged into a single NFA
        by simply alternating the individual NFAs for each rule, which is the 
        equivalent of the regular expression "{rule1}|{rule2}|{rule3}".</p>
        <p>To keep track of which rule is which, the <strong>ids</strong> 
        property of each NFA state is tagged with the name of the rule that 
        the state originated from. The <strong>final_ids</strong> property for 
        the final state is tagged with a rule name as well. When the states 
        are combined later, the tags identify which rules are matched when the 
        state machine is in the combined state.</p>
        
        <h2>Converting the NFA to a DFA</h2>
        <p><em>Source files:</em></p>
        <ul>
            <li><em>NFA to DFA: <a href="">Generator/DeterministicFiniteAutomataBuilder.py</a></em></li>
            <li><em>DFA Structure: <a href="">Generator/_DeterministicFiniteAutomata.py</a></em></li>
        </ul>
        
        <p>NFAs are not ideal for single-threaded CPU execution (though they 
        are highly-parallel processors such as FPGAs), so Poodle-Lex next
        converts the NFA to a 
        <a href="">deterministic finite automata (DFA)</a>
        A DFA is a state machine which can only be in one state at a time,
        and state transitions only occur due to input characters. In 
        Poodle-Lex, they are represented by the 
        <a href="">DeterministicFiniteAutomata</a> class.</p>
        
        <h3>The DFA data structure</h3>
        <p>The DeterministicFiniteAutomata class is equivalent to the 
        NondeterministicFiniteAutomata class, except that there are no 
        epsilon edges, and no unified end state. The class exists to 
        point to a single 
        <a href="">DeterministicState</a>
        object representing the start state. The DeterministicState object 
        contains the same <strong>edges</strong>, <strong>ids</strong>,
        and <strong>final_ids</strong> fields as the NFA data structure.
        The only difference is that edges now points to other
        DeterministicState objects instead of NondeterministicState 
        objects.</p>
        <p>A populated <strong>final_ids</strong> property indicates that a 
        given state is a final state. For instace, consider the following DFA. 
        The DFA matches 'a' or 'aaa', like the NFA from the previous 
        section. States with double outlines are final states.</p>
        <img src="simple-dfa.png" alt="A simple DFA matching 'a' or 'aaa'" />
        <p>This state machine can be created with the following Python code:</p>
        <code># Value of an edge 'a'
a = CoverageSet([(ord('a'), ord('a'))])
        
# State machine and states
state_machine = Automata.DeterministicFiniteAutomata()
s1 = Automata.DeterministicState()
s2 = Automata.DeterministicState()
s3 = Automata.DeterministicState()
s1.final_ids.add('rule')
s3.final_ids.add('rule')

# Edges
state_machine.start_state.edges[s1] = a
s1.edges[s2] = a
s2.edges[s3] = a</code>
        
        <h3>Converting an NFA to a DFA</h3>
        <p>An NFA can exist in multiple states at once. To convert an NFA to a 
        DFA, every combination of multiple NFA states the state machine can be
        in at one time must be found. Each combination of simultaneous states
        is then considered one DFA state. This process is called 
        <a href="">powerset construction</a> and is described in more detail
        in other widely available resources.</p>
        <p>Poodle-Lex performs this process by completely traversing the NFA,
        and finding the <strong>epsilon closure</strong> of each state the 
        traverser is in. The epsilon closure of a set of NFA states is a set 
        of all the states given, plus all the states reachable 
        through epsilon edges. It finds all the simultaneous states a 
        traverser can be in. Poodle-Lex uses a separate recursive crawler, 
        the <a href="">EpsilonClosureCrawler</a> class, to 
        find the epsilon closure for a set of states.</p>
        <p>The 
        <a href="">DeterministicFiniteAutomataBuilder</a>
        class is responsible for converting the NFA to a DFA. It starts by 
        taking the epsilon closure of the start state of the NFA. Then, a DFA 
        is created, and its start state is mapped to the epsilon closure.</p>
        <p>The builder then traverses the NFA. For every new combination of 
        states the builder is in, it expands the set to include the epsilon 
        closure of those states. Then it creates a DFA state to represent that
        combination of states. This process gradually builds up the DFA as it 
        traverses the NFA. When the NFA is completely traversed, and no new 
        combinations of NFA states are found, the DFA is an equivalent state 
        machine to the NFA.</p>
        <p>When a DFA state is created from a set of NFA states, the values of 
        <strong>ids</strong> and <strong>final_ids</strong> for the DFA state
        is the union of all the values of <strong>ids</strong> and 
        <strong>final_ids</strong> of the NFA. This allows a DFA state to be
        matched to one or more rules.</p>
        
        <h2>Minimizing the DFA</h2>
        <p><em>Source files:</em></p>
        <ul>
            <li><em>Hopcroft: <a href="">Generator/HopcroftDFAMinimizer.py</a></em></li>
            <li><em>Polynomial: <a href="">Generator/NaiveDFAMinimizer.py</a></em></li>
        </ul>
        
        <p>When a DFA is created from an NFA, there is enough information to 
        create equivalent source code. But the source code may be inefficient. 
        Before emitting source code, Poodle-Lex (and most similar programs) 
        minimize the state machine to reduce the number of states.</p>
        <p>A popular algorithm for minimizing a state machine is 
        <a href="">Hopcroft's Algorithm</a>,
        which costs 
        <a href="http://en.wikipedia.org/wiki/Big_O_notation">n*s*O(n)^2</a> 
        iterations, where n is the number of states and s is the size of the
        input alphabet. Poodle-Lex, by default, minimizes the state machine 
        using an implementation of this algorithm.</p>
        <p>Poodle-Lex also includes a basic O(n^2) algorithm which compares
        each state to each state and merges them if they are equivalent. This 
        implementation is several times slower, however, and only exists 
        for demonstrative purposes and for internal unit testing.</p>
        
        <h2>Generating source code from the DFA</h2>
        <p><em>Source files:</em></p>
        <ul>
            <li><em>Plugin loader: <a href="">Generator/LanguagePlugins.py</a></em></li>
            <li><em>Plugin template: <a href="">Generator/Emitter/PluginTemplate.py</a></em></li>
            <li><em>Freebasic emitter: <a href="">Plugins/FreeBasic/FreeBasic.py</a></em></li>
            <li><em>C-Ascii emitter: <a href="">Plugins/C-Ascii/C-Ascii.py</a></em></li>
        </ul>

        <p>DFA state machines can be easily represented in most programming
        languages. Consider the state machine from previous sections:</p>
        <img src="simple-dfa.png" alt="A simple NFA matching 'a' or 'aaa'" />
        <p>This state machine can be represented with the following 
        (badly written and not recommended) code:</p>
        <code>int accept(FILE* f) {
    start: if (fgetc(f) == 'a') goto s1;
           else return FALSE;
    s1:    if (fgetc(f) == 'a') goto s2;
           else return TRUE;
    s2:    if (fgetc(f) == 'a') goto s3;
           else return FALSE;
    s3:    return TRUE;
}</code>
        <p>The last step Poodle-Lex takes it to generate source code 
        equivalent to the DFA. In order to maintain flexibility, 
        Poodle-Lex relies on emitter plugins written in Python.</p>
        <p>Emitter plugins are defined in 
        <strong>Plugins/Plugins.json</strong>. The json file
        contains a list of plug-ins
    
        
    </body>
</html>